#概念 

# 定义
## 黄皮书中

A transaction (formally, $T$) is a single cryptographically-signed instruction constructed by an actor externally to the scope of Ethereum. The sender of a transaction cannot be a contract. While it is assumed that the ultimate external actor will be human in nature, software tools will be used in its construction and dissemination³.

EIP-2718 by Zoltu [2020] introduced the notion of different transaction types. As of the London version of the protocol, there are three transaction types:

- **0 (legacy)**
- **1 (EIP-2930 by Buterin and Swende [2020b])**
- **2 (EIP-1559 by Buterin et al. [2019])**

Further, there are two subtypes of transactions:

1. Those which result in **message calls**.
2. Those which result in the **creation of new accounts with associated code** (known informally as "contract creation").

All transaction types specify a number of common fields:

- **type**: EIP-2718 transaction type; formally $T_x$.
- **nonce**: A scalar value equal to the number of transactions sent by the sender; formally $T_n$.
- **gasLimit**: A scalar value equal to the maximum amount of gas that should be used in executing this transaction. This is paid up-front, before any computation is done and may not be increased later; formally $T_g$.
- **to**: The 160-bit address of the message call’s recipient or, for a contract creation transaction, $\varnothing$, used here to denote the only member of $B_0$; formally $T_t$.
- **value**: A scalar value equal to the number of Wei to be transferred to the message call’s recipient or, in the case of contract creation, as an endowment to the newly created account; formally $T_v$.
- **r, s**: Values corresponding to the signature of the transaction and used to determine the sender of the transaction; formally $T_r$ and $T_s$. .

#### Additional Fields for EIP-2930 (Type 1) and EIP-1559 (Type 2) Transactions:

- **accessList**: List of access entries to warm up; formally $T_A$. Each access list entry $E$ is a tuple of an account address and a list of storage keys:
  $$E \equiv (E_a, E_s)$$
  
- **chainId**: Chain ID; formally $T_c$. Must be equal to the network chain ID $\beta$.
- **yParity**: Signature Y parity; formally $T_y$.

**Legacy transactions** do not have an `accessList` ($T_A = ()$), while `chainId` and `yParity` for legacy transactions are combined into a single value:

- **w**: A scalar value encoding Y parity and possibly chain ID; formally $T_w$.

$$T_w = 27 + T_y \quad \text{or} \quad T_w = 2\beta + 35 + T_y$$
  (see **EIP-155 by Buterin [2016]**).

---

There are differences in how one’s acceptable gas price is specified in **Type 2 transactions** versus **Type 0 and Type 1 transactions**. Type 2 transactions take better advantage of the gas market improvements introduced in **EIP-1559** by explicitly limiting the priority fee⁴ that is paid.

Type 2 transactions have the following two fields related to gas:

- **maxFeePerGas**: A scalar value equal to the maximum number of Wei to be paid per unit of gas for all computation costs incurred as a result of the execution of this transaction; formally $T_m$.
- **maxPriorityFeePerGas**: A scalar value equal to the maximum number of Wei to be paid to the block’s fee recipient as an incentive to include the transaction; formally $T_f$.

In contrast, **Type 0 and Type 1 transactions** specify gas price as a single value:

- **gasPrice**: A scalar value equal to the number of Wei to be paid per unit of gas for all computation costs incurred as a result of the execution of this transaction; formally $T_p$.

---

### Additional Fields for Contract Creation Transactions:

A contract creation transaction (regardless of transaction type) contains:

- **init**: An unlimited size byte array specifying the EVM-code for the account initialization procedure, formally $T_i$.

`init` is an EVM-code fragment; it returns the **body**, a second fragment of code that executes each time the account receives a message call (either through a transaction or due to the internal execution of code). `init` is executed only once at account creation and gets discarded immediately thereafter.

---

### Additional Fields for Message Call Transactions:

A message call transaction contains:

- **data**: An unlimited size byte array specifying the input data of the message call, formally $T_d$.

## 代码中

```go
// TxData is the underlying data of a transaction.
//
// This is implemented by DynamicFeeTx, LegacyTx and AccessListTx.
type TxData interface {
	txType() byte // returns the type ID
	copy() TxData // creates a deep copy and initializes all fields

	chainID() *big.Int
	accessList() AccessList
	data() []byte
	gas() uint64
	gasPrice() *big.Int
	gasTipCap() *big.Int
	gasFeeCap() *big.Int
	value() *big.Int
	nonce() uint64
	to() *common.Address

	rawSignatureValues() (v, r, s *big.Int)
	setSignatureValues(chainID, v, r, s *big.Int)

	// effectiveGasPrice computes the gas price paid by the transaction, given
	// the inclusion block baseFee.
	//
	// Unlike other TxData methods, the returned *big.Int should be an independent
	// copy of the computed value, i.e. callers are allowed to mutate the result.
	// Method implementations can use 'dst' to store the result.
	effectiveGasPrice(dst *big.Int, baseFee *big.Int) *big.Int

	encode(*bytes.Buffer) error
	decode([]byte) error
}

```

由如下几种type implement
- LegacyTx (type 0)
- AccessListTx(EIP-2930,type1)
- DynamicFeeTx （EIP-1559，type2)
- BlobTxType（EIP-4844，type3)
- SetCodeTx  (EIP-7702, type4)


注意到，新增了两种type，在黄皮书里没有。EIP-4844 里交易携带了blob 数据，为未来的L2 Rollup 做准备。EIP-7702 允许了EOA 在交易期间也能像是合约账户一样执行智能合约。
在分析代码时，我使用type2 为例，研究实现。


